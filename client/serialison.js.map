{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/johann/Development/serialison/entry-points/browser.js",
    "/Users/johann/Development/serialison/lib/mapper.js",
    "/Users/johann/Development/serialison/lib/resolver.js",
    "/Users/johann/Development/serialison/lib/serialison.js",
    "/Users/johann/Development/serialison/lib/utils.js",
    "node_modules/core-js/src/$.assert.js",
    "node_modules/core-js/src/$.assign.js",
    "node_modules/core-js/src/$.cof.js",
    "node_modules/core-js/src/$.ctx.js",
    "node_modules/core-js/src/$.def.js",
    "node_modules/core-js/src/$.invoke.js",
    "node_modules/core-js/src/$.iter.js",
    "node_modules/core-js/src/$.js",
    "node_modules/core-js/src/$.keyof.js",
    "node_modules/core-js/src/$.partial.js",
    "node_modules/core-js/src/$.set-proto.js",
    "node_modules/core-js/src/$.species.js",
    "node_modules/core-js/src/$.string-at.js",
    "node_modules/core-js/src/$.uid.js",
    "node_modules/core-js/src/$.wks.js",
    "node_modules/core-js/src/es6.array.statics.js",
    "node_modules/core-js/src/es6.collections.js",
    "node_modules/core-js/src/es6.iterators.js",
    "node_modules/core-js/src/es6.object.statics.js",
    "node_modules/core-js/src/es6.symbol.js",
    "node_modules/regenerator-babel/runtime.js"
  ],
  "names": [],
  "mappings": "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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// We want only what we need to reduce the size of the final output\nrequire('core-js/src/es6.symbol');\nrequire('core-js/src/es6.object.statics');\nrequire('core-js/src/es6.array.statics');\nrequire('core-js/src/es6.collections');\nrequire('regenerator-babel/runtime');\n\n// Export the library\nmodule.exports = require('../lib/serialison');\n",
    "import {each, isDefined, isString} from './utils';\n\nexport class Mapper {\n\n    constructor(options = {})\n    {\n        this.options = Object.assign({\n            throwErrorsForDuplicateIDs: true,\n            throwErrorsForDuplicateUrlTemplates: true\n        }, options);\n\n        this.resources = {};\n        this.resourcePaths = {};\n    }\n\n    /**\n     * Returns the real type of the resources by checking the \"type\" property in each resource\n     */\n    getType(resourceType, ...resources)\n    {\n        var typesSet = new Set;\n\n        for (let {value: resource} of each(resources)) {\n            if (resource.type) {\n                typesSet.add(resource.type);\n            }\n        }\n\n        if (typesSet.size == 1) {\n            resourceType = Array.from(typesSet.values())[0];\n        } else if (typesSet.size > 1) {\n            let types = JSON.stringify(Array.from(typesSet.values()));\n            throw new Error(`Multiple types found in the provided resources: ${types}`);\n        }\n\n        return resourceType;\n    }\n\n    /**\n     * Adds an URL template\n     */\n    addUrlTemplate(resourcePath, urlTemplate)\n    {\n        if (this.resourcePaths[resourcePath] && this.options.throwErrorsForDuplicateUrlTemplates) {\n            throw new Error(`Multiple URL templates with the same path found: \"${resourcePath}\"`);\n        }\n\n        if (isString(urlTemplate.type)) {\n            // We must declare a getter since the resource type isn't necessarily created at the moment.\n            // We don't use a native getter but a function so we can test its existence just above.\n            this.resourcePaths[resourcePath] = () => this.resources[urlTemplate.type];\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds multiple resources with the same type to the map\n     */\n    addResources(resourceKey, ...resources)\n    {\n        // If the resource key is undefined, abort the execution.\n        if (!resourceKey) {\n            return this;\n        }\n\n        // Get the real type of the resources\n        var resourceType = this.getType(resourceKey, ...resources);\n\n        // Add the resource type if it doesn't exist in the map\n        var mappedType = this.resources[resourceType] = this.resources[resourceType] || {};\n\n        // Iterate over each resource and add it to the map\n        for (let {value: resource} of each(resources)) {\n\n            // Ignore the resource if undefined or if it hasn't any ID\n            if (!isDefined(resource) || !isDefined(resource.id)) {\n                continue;\n            }\n\n            // Add the resource if the ID doesn't already exist\n            if (!isDefined(mappedType[resource.id.toString()])) {\n                mappedType[resource.id.toString()] = resource;\n            } else if (this.options.throwErrorsForDuplicateIDs) {\n                throw new Error(\"A resource with the same type and ID already exists\");\n            }\n\n        }\n\n        return this;\n    }\n\n    /**\n     * Retrieves a resource from its path, type and ID\n     */\n    getResource(resourcePath, resourceType, id)\n    {\n        var mappedType = (this.resourcePaths[resourcePath] || () => {})() || this.resources[resourceType] || {};\n\n        return mappedType[id.toString()] || null;\n    }\n\n};\n",
    "import {each, transform, isString} from './utils';\n\nexport class Resolver {\n\n    constructor(mapperInstance, options = {})\n    {\n        this.options = Object.assign({\n            maxNestingDepth: 4,\n            stripLinksProperty: true,\n            resourceTransformers: []\n        }, options);\n\n        this.mapper = mapperInstance;\n\n        this.nestingPath = [];\n    }\n\n    /**\n     * Returns the resource(s) once all the links are resolved\n     */\n    resolve(resourceKey, resources)\n    {\n        if (this.nestingPath.length < this.options.maxNestingDepth) {\n            // If we have a collection of resources, call recursively the resolve() method for each resource.\n            if (Array.isArray(resources)) {\n                for (let {key: resourceIndex, value: resource} of each(resources)) {\n                    resources[resourceIndex] = this.resolve(resourceKey, resource);\n                }\n            }\n\n            // Link the relationships of the current resource\n            else if (resources) {\n                this.nestingPath.push(resourceKey);\n\n                for (let {key: relationshipKey, value: relationship} of each(resources.links || {})) {\n                    let relatedResources = this.link(relationshipKey, relationshipKey, relationship);\n\n                    if (relatedResources != null) {\n                        resources[relationshipKey] = relatedResources;\n                    }\n                }\n\n                resources = transform(resources, [this.defaultTransformer()].concat(this.options.resourceTransformers));\n\n                this.nestingPath.pop();\n            }\n        }\n\n        return resources;\n    }\n\n    /**\n     * Returns the related resource(s) once they have been resolved\n     */\n    link(relationshipKey, relationshipType, relationships)\n    {\n        // If the relationship contains an array of IDs, call recursively the link method() for each ID.\n        if (Array.isArray(relationships)) {\n            return this.linkMultipleIds(relationshipKey, relationshipType, relationships);\n        }\n\n        // If the relationship is not a string, assume it's a resource object.\n        else if (!isString(relationships)) {\n            // Get the real type of the resource\n            let relationshipType = relationships.type || relationshipKey;\n\n            // Only one ID\n            if (relationships.id) {\n                return this.link(relationshipKey, relationshipType, relationships.id.toString());\n            }\n\n            // Multiples IDs\n            else if (relationships.ids) {\n                return this.linkMultipleIds(relationshipKey, relationshipType, relationships);\n            }\n\n            return null;\n        }\n\n        // If the relationship is a string, we can retrieve the resource.\n        else {\n            let relationshipPath = this.nestingPath.concat(relationshipKey).join('.'),\n                resource = this.mapper.getResource(relationshipPath, relationshipType, relationships);\n\n            return this.resolve(relationshipKey, resource);\n        }\n    }\n\n    /**\n     * Returns the related collection of resources\n     */\n    linkMultipleIds(relationshipKey, relationshipType, relationships)\n    {\n        var resources = [];\n\n        for (let {value: relationshipID} of each(relationships)) {\n            let resource = this.link(relationshipKey, relationshipType, relationshipID.toString());\n\n            if (resource) {\n                resources.push(resource);\n            }\n        }\n\n        return resources.length ? resources : null;\n    }\n\n    /**\n     * Returns the default transformer used to strip the `links` property of each resource\n     */\n    defaultTransformer()\n    {\n        var self = this;\n\n        return function(resource) {\n            if (self.options.stripLinksProperty) {\n                delete resource.links;\n            }\n\n            return resource;\n        };\n    }\n\n};\n",
    "import {Mapper} from './mapper';\nimport {Resolver} from './resolver';\nimport {each, transform, isObject} from './utils';\n\n/**\n * Provides an entry point to configure and run JSON resolving\n */\nclass SerialiSON {\n\n    constructor(mainDocument, options = {})\n    {\n        this.options = Object.assign({\n            topLevelProperties: ['meta', 'links', 'linked'],\n            stripTopLinkingProperties: true,\n            mainDocumentTransformers: []\n        }, options);\n\n        this.mapper = new Mapper(options);\n        this.resolver = new Resolver(this.mapper, options);\n\n        // Save the main document and add it to the internal map\n        if (!isObject(mainDocument)) {\n            throw new Error(\"The main document must be a valid object\");\n        }\n\n        this.mainDocument = mainDocument;\n        this.addDocument(mainDocument);\n    }\n\n    /**\n     * Returns the primary resource key of a document\n     */\n\n    getPrimaryResourceKey(document)\n    {\n        return document.data\n            ? 'data'\n            : Object.keys(document).filter(key => !~this.options.topLevelProperties.indexOf(key))[0];\n    }\n\n    /**\n     * Retrieves all the resources of a document and adds them to the internal map\n     */\n    addDocument(document)\n    {\n        if (!isObject(document)) {\n            return this;\n        }\n\n        var primaryResourceKey = this.getPrimaryResourceKey(document),\n            primaryResource = document[primaryResourceKey];\n\n        // Map the main resource(s)\n        this.mapper.addResources(primaryResourceKey, ...(primaryResource || {}));\n\n        // Map the linked resources\n        for (let {key: resourceType, value: resources} of each(document.linked || [])) {\n            this.mapper.addResources(resourceType, ...resources);\n        }\n\n        // Map the URL templates\n        for (let {key: resourcePath, value: urlTemplate} of each(document.links || [])) {\n            this.mapper.addUrlTemplate(resourcePath, urlTemplate);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the main document once all the links are resolved\n     */\n    resolve()\n    {\n        var mainDocument = JSON.parse(JSON.stringify(this.mainDocument)), // Create a copy of the document\n            primaryResourceKey = this.getPrimaryResourceKey(mainDocument),\n            primaryResource = mainDocument[primaryResourceKey];\n\n        if (primaryResource) {\n            mainDocument[primaryResourceKey] = this.resolver.resolve(primaryResourceKey, primaryResource);\n        }\n\n        mainDocument = transform(\n            mainDocument,\n            [this.defaultTransformer()].concat(this.options.mainDocumentTransformers)\n        );\n\n        return mainDocument;\n    }\n\n    /**\n     * Returns the default transformer used to strip the top linking properties of the main document\n     */\n    defaultTransformer()\n    {\n        var self = this;\n\n        return function(mainDocument) {\n            if (self.options.stripTopLinkingProperties) {\n                delete mainDocument.links;\n                delete mainDocument.linked;\n            }\n\n            return mainDocument;\n        };\n    }\n\n};\n\n// Export the SerialiSON class for Node/Browserify\nif (isObject(module)) {\n    module.exports = SerialiSON;\n}\n",
    "/**\n * Returns a generator used to iterate over object or array properties\n */\nexport function* each(collection)\n{\n    if (Array.isArray(collection)) {\n        for (let index = 0 ; index < collection.length ; index++) {\n            yield {key: index, value: collection[index]};\n        }\n    } else if (isObject(collection)) {\n        for (let key of Object.keys(collection)) {\n            yield {key, value: collection[key]};\n        }\n    } else {\n        throw new Error(\"First parameter should be an Object or an Array\");\n    }\n};\n\n/**\n * Transforms an object\n */\nexport function transform(object, transformers)\n{\n    for (let {value: transform} of each(transformers)) {\n        if (typeof transform == 'function') {\n            object = transform(object);\n        }\n    }\n\n    return object;\n}\n\n/**\n * Returns true if the value is defined\n */\nexport function isDefined(value) {\n    return typeof value !== 'undefined';\n};\n\n/**\n * Returns true if the value is an object\n */\nexport function isObject(value) {\n    return value !== null && isDefined(value) && typeof value.valueOf() === 'object';\n};\n\n/**\n * Returns true if the value is a string\n */\nexport function isString(value) {\n    return value !== null && isDefined(value) && typeof value.valueOf() === 'string';\n};\n",
    "var $ = require('./$');\r\nfunction assert(condition, msg1, msg2){\r\n  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);\r\n};\r\nassert.def = $.assertDefined;\r\nassert.fn = function(it){\r\n  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');\r\n  return it;\r\n};\r\nassert.obj = function(it){\r\n  if(!$.isObject(it))throw TypeError(it + ' is not an object!');\r\n  return it;\r\n};\r\nassert.inst = function(it, Constructor, name){\r\n  if(!(it instanceof Constructor))throw TypeError(name + \": use the 'new' operator!\");\r\n  return it;\r\n};\r\nmodule.exports = assert;",
    "var $ = require('./$');\r\n// 19.1.2.1 Object.assign(target, source, ...)\r\nmodule.exports = Object.assign || function(target, source){\r\n  var T = Object($.assertDefined(target))\r\n    , l = arguments.length\r\n    , i = 1;\r\n  while(l > i){\r\n    var S      = $.ES5Object(arguments[i++])\r\n      , keys   = $.getKeys(S)\r\n      , length = keys.length\r\n      , j      = 0\r\n      , key;\r\n    while(length > j)T[key = keys[j++]] = S[key];\r\n  }\r\n  return T;\r\n}",
    "var $        = require('./$')\r\n  , TAG      = require('./$.wks')('toStringTag')\r\n  , toString = {}.toString;\r\nfunction cof(it){\r\n  return toString.call(it).slice(8, -1);\r\n}\r\ncof.classof = function(it){\r\n  var O, T;\r\n  return it == undefined ? it === undefined ? 'Undefined' : 'Null'\r\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);\r\n}\r\ncof.set = function(it, tag, stat){\r\n  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);\r\n}\r\nmodule.exports = cof;",
    "// Optional / simple context binding\r\nvar assertFunction = require('./$.assert').fn;\r\nmodule.exports = function(fn, that, length){\r\n  assertFunction(fn);\r\n  if(~length && that === undefined)return fn;\r\n  switch(length){\r\n    case 1: return function(a){\r\n      return fn.call(that, a);\r\n    }\r\n    case 2: return function(a, b){\r\n      return fn.call(that, a, b);\r\n    }\r\n    case 3: return function(a, b, c){\r\n      return fn.call(that, a, b, c);\r\n    }\r\n  } return function(/* ...args */){\r\n      return fn.apply(that, arguments);\r\n  }\r\n}",
    "var $          = require('./$')\r\n  , global     = $.g\r\n  , core       = $.core\r\n  , isFunction = $.isFunction;\r\nfunction ctx(fn, that){\r\n  return function(){\r\n    return fn.apply(that, arguments);\r\n  }\r\n}\r\nif($.FW)global.core = core;\r\n// type bitmap\r\n$def.F = 1;  // forced\r\n$def.G = 2;  // global\r\n$def.S = 4;  // static\r\n$def.P = 8;  // proto\r\n$def.B = 16; // bind\r\n$def.W = 32; // wrap\r\nfunction $def(type, name, source){\r\n  var key, own, out, exp\r\n    , isGlobal = type & $def.G\r\n    , target   = isGlobal ? global : (type & $def.S)\r\n        ? global[name] : (global[name] || {}).prototype\r\n    , exports  = isGlobal ? core : core[name] || (core[name] = {});\r\n  if(isGlobal)source = name;\r\n  for(key in source){\r\n    // contains in native\r\n    own = !(type & $def.F) && target && key in target;\r\n    // export native or passed\r\n    out = (own ? target : source)[key];\r\n    // prevent global pollution for namespaces\r\n    if(!$.FW && isGlobal && !isFunction(target[key]))exp = source[key];\r\n    // bind timers to global for call from export context\r\n    else if(type & $def.B && own)exp = ctx(out, global);\r\n    // wrap global constructors for prevent change them in library\r\n    else if(type & $def.W && !$.FW && target[key] == out)!function(out){\r\n      exp = function(param){\r\n        return this instanceof out ? new out(param) : out(param);\r\n      }\r\n      exp.prototype = out.prototype;\r\n    }(out);\r\n    else exp = type & $def.P && isFunction(out) ? ctx(Function.call, out) : out;\r\n    // extend global\r\n    if($.FW && target && !own){\r\n      if(isGlobal)target[key] = out;\r\n      else delete target[key] && $.hide(target, key, out);\r\n    }\r\n    // export\r\n    if(exports[key] != out)$.hide(exports, key, exp);\r\n  }\r\n}\r\nmodule.exports = $def;",
    "// Fast apply\r\n// http://jsperf.lnkit.com/fast-apply/5\r\nmodule.exports = function(fn, args, that){\r\n  var un = that === undefined;\r\n  switch(args.length){\r\n    case 0: return un ? fn()\r\n                      : fn.call(that);\r\n    case 1: return un ? fn(args[0])\r\n                      : fn.call(that, args[0]);\r\n    case 2: return un ? fn(args[0], args[1])\r\n                      : fn.call(that, args[0], args[1]);\r\n    case 3: return un ? fn(args[0], args[1], args[2])\r\n                      : fn.call(that, args[0], args[1], args[2]);\r\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\r\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\r\n    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])\r\n                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);\r\n  } return              fn.apply(that, args);\r\n}",
    "'use strict';\r\nvar $                 = require('./$')\r\n  , ctx               = require('./$.ctx')\r\n  , cof               = require('./$.cof')\r\n  , $def              = require('./$.def')\r\n  , assertObject      = require('./$.assert').obj\r\n  , SYMBOL_ITERATOR   = require('./$.wks')('iterator')\r\n  , FF_ITERATOR       = '@@iterator'\r\n  , Iterators         = {}\r\n  , IteratorPrototype = {};\r\n// Safari has byggy iterators w/o `next`\r\nvar BUGGY = 'keys' in [] && !('next' in [].keys());\r\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\r\nsetIterator(IteratorPrototype, $.that);\r\nfunction setIterator(O, value){\r\n  $.hide(O, SYMBOL_ITERATOR, value);\r\n  // Add iterator for FF iterator protocol\r\n  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);\r\n}\r\nfunction createIterator(Constructor, NAME, next, proto){\r\n  Constructor.prototype = $.create(proto || $iter.prototype, {next: $.desc(1, next)});\r\n  cof.set(Constructor, NAME + ' Iterator');\r\n}\r\nfunction defineIterator(Constructor, NAME, value, DEFAULT){\r\n  var proto = Constructor.prototype\r\n    , iter  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || (DEFAULT && proto[DEFAULT]) || value;\r\n  if($.FW){\r\n    // Define iterator\r\n    setIterator(proto, iter);\r\n    if(iter !== value){\r\n      var iterProto = $.getProto(iter.call(new Constructor));\r\n      // Set @@toStringTag to native iterators\r\n      cof.set(iterProto, NAME + ' Iterator', true);\r\n      // FF fix\r\n      $.has(proto, FF_ITERATOR) && setIterator(iterProto, $.that);\r\n    }\r\n  }\r\n  // Plug for library\r\n  Iterators[NAME] = iter;\r\n  // FF & v8 fix\r\n  Iterators[NAME + ' Iterator'] = $.that;\r\n  return iter;\r\n}\r\nfunction getIterator(it){\r\n  var Symbol  = $.g.Symbol\r\n    , ext     = it[Symbol && Symbol.iterator || FF_ITERATOR]\r\n    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[cof.classof(it)];\r\n  return assertObject(getIter.call(it));\r\n}\r\nfunction closeIterator(iterator){\r\n  var ret = iterator['return'];\r\n  if(ret !== undefined)ret.call(iterator);\r\n}\r\nfunction stepCall(iterator, fn, value, entries){\r\n  try {\r\n    return entries ? fn(value[0], value[1]) : fn(value);\r\n  } catch(e){\r\n    closeIterator(iterator);\r\n    throw e;\r\n  }\r\n}\r\nvar DANGER_CLOSING = true;\r\ntry {\r\n  var iter = [1].keys();\r\n  iter['return'] = function(){ DANGER_CLOSING = false };\r\n  Array.from(iter, function(){ throw 2 });\r\n} catch(e){}\r\nvar $iter = module.exports = {\r\n  BUGGY: BUGGY,\r\n  DANGER_CLOSING: DANGER_CLOSING,\r\n  Iterators: Iterators,\r\n  prototype: IteratorPrototype,\r\n  step: function(done, value){\r\n    return {value: value, done: !!done};\r\n  },\r\n  stepCall: stepCall,\r\n  close: closeIterator,\r\n  is: function(it){\r\n    var O      = Object(it)\r\n      , Symbol = $.g.Symbol\r\n      , SYM    = Symbol && Symbol.iterator || FF_ITERATOR;\r\n    return SYM in O || SYMBOL_ITERATOR in O || $.has(Iterators, cof.classof(O));\r\n  },\r\n  get: getIterator,\r\n  set: setIterator,\r\n  create: createIterator,\r\n  define: defineIterator,\r\n  std: function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){\r\n    function createIter(kind){\r\n      return function(){\r\n        return new Constructor(this, kind);\r\n      }\r\n    }\r\n    createIterator(Constructor, NAME, next);\r\n    var entries = createIter('key+value')\r\n      , values  = createIter('value')\r\n      , proto   = Base.prototype\r\n      , methods, key;\r\n    if(DEFAULT == 'value')values = defineIterator(Base, NAME, values, 'values');\r\n    else entries = defineIterator(Base, NAME, entries, 'entries');\r\n    if(DEFAULT){\r\n      methods = {\r\n        entries: entries,\r\n        keys:    IS_SET ? values : createIter('key'),\r\n        values:  values\r\n      }\r\n      $def($def.P + $def.F * BUGGY, NAME, methods);\r\n      if(FORCE)for(key in methods){\r\n        if(!(key in proto))$.hide(proto, key, methods[key]);\r\n      }\r\n    }\r\n  },\r\n  forOf: function(iterable, entries, fn, that){\r\n    var iterator = getIterator(iterable)\r\n      , f = ctx(fn, that, entries ? 2 : 1)\r\n      , step;\r\n    while(!(step = iterator.next()).done){\r\n      if(stepCall(iterator, f, step.value, entries) === false){\r\n        return closeIterator(iterator);\r\n      }\r\n    }\r\n  }\r\n};",
    "'use strict';\r\nvar global = typeof self != 'undefined' ? self : Function('return this')()\r\n  , core   = {}\r\n  , defineProperty = Object.defineProperty\r\n  , hasOwnProperty = {}.hasOwnProperty\r\n  , ceil  = Math.ceil\r\n  , floor = Math.floor\r\n  , max   = Math.max\r\n  , min   = Math.min;\r\n// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\r\nvar DESC = !!function(){try {\r\n  return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;\r\n} catch(e){}}();\r\nvar hide = createDefiner(1);\r\n// 7.1.4 ToInteger\r\nfunction toInteger(it){\r\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\r\n}\r\nfunction desc(bitmap, value){\r\n  return {\r\n    enumerable  : !(bitmap & 1),\r\n    configurable: !(bitmap & 2),\r\n    writable    : !(bitmap & 4),\r\n    value       : value\r\n  }\r\n}\r\nfunction simpleSet(object, key, value){\r\n  object[key] = value;\r\n  return object;\r\n}\r\nfunction createDefiner(bitmap){\r\n  return DESC ? function(object, key, value){\r\n    return $.setDesc(object, key, desc(bitmap, value));\r\n  } : simpleSet;\r\n}\r\n\r\nfunction isObject(it){\r\n  return it !== null && (typeof it == 'object' || typeof it == 'function');\r\n}\r\nfunction isFunction(it){\r\n  return typeof it == 'function';\r\n}\r\nfunction assertDefined(it){\r\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\r\n  return it;\r\n}\r\n\r\nvar $ = module.exports = {\r\n  g: global,\r\n  FW: true,\r\n  path: global,\r\n  core: core,\r\n  html: global.document && document.documentElement,\r\n  // http://jsperf.com/core-js-isobject\r\n  isObject:   isObject,\r\n  isFunction: isFunction,\r\n  it: function(it){\r\n    return it;\r\n  },\r\n  that: function(){\r\n    return this;\r\n  },\r\n  // 7.1.4 ToInteger\r\n  toInteger: toInteger,\r\n  // 7.1.15 ToLength\r\n  toLength: function(it){\r\n    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\r\n  },\r\n  toIndex: function(index, length){\r\n    var index = toInteger(index);\r\n    return index < 0 ? max(index + length, 0) : min(index, length);\r\n  },\r\n  has: function(it, key){\r\n    return hasOwnProperty.call(it, key);\r\n  },\r\n  create:     Object.create,\r\n  getProto:   Object.getPrototypeOf,\r\n  DESC:       DESC,\r\n  desc:       desc,\r\n  getDesc:    Object.getOwnPropertyDescriptor,\r\n  setDesc:    defineProperty,\r\n  getKeys:    Object.keys,\r\n  getNames:   Object.getOwnPropertyNames,\r\n  getSymbols: Object.getOwnPropertySymbols,\r\n  // Dummy, fix for not array-like ES3 string in es5 module\r\n  assertDefined: assertDefined,\r\n  ES5Object: Object,\r\n  toObject: function(it){\r\n    return $.ES5Object(assertDefined(it));\r\n  },\r\n  hide: hide,\r\n  def: createDefiner(0),\r\n  set: global.Symbol ? simpleSet : hide,\r\n  mix: function(target, src){\r\n    for(var key in src)hide(target, key, src[key]);\r\n    return target;\r\n  },\r\n  // $.a('str1,str2,str3') => ['str1', 'str2', 'str3']\r\n  a: function(it){\r\n    return String(it).split(',');\r\n  },\r\n  each: [].forEach\r\n};\r\nif(typeof __e != 'undefined')__e = core;\r\nif(typeof __g != 'undefined')__g = global;",
    "var $ = require('./$');\r\nmodule.exports = function(object, el){\r\n  var O      = $.toObject(object)\r\n    , keys   = $.getKeys(O)\r\n    , length = keys.length\r\n    , index  = 0\r\n    , key;\r\n  while(length > index)if(O[key = keys[index++]] === el)return key;\r\n}",
    "'use strict';\r\nvar $      = require('./$')\r\n  , invoke = require('./$.invoke')\r\n  , assertFunction = require('./$.assert').fn;\r\nmodule.exports = function(/* ...pargs */){\r\n  var fn     = assertFunction(this)\r\n    , length = arguments.length\r\n    , pargs  = Array(length)\r\n    , i      = 0\r\n    , _      = $.path._\r\n    , holder = false;\r\n  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;\r\n  return function(/* ...args */){\r\n    var that    = this\r\n      , _length = arguments.length\r\n      , i = 0, j = 0, args;\r\n    if(!holder && !_length)return invoke(fn, pargs, that);\r\n    args = pargs.slice();\r\n    if(holder)for(;length > i; i++)if(args[i] === _)args[i] = arguments[j++];\r\n    while(_length > j)args.push(arguments[j++]);\r\n    return invoke(fn, args, that);\r\n  }\r\n}",
    "// Works with __proto__ only. Old v8 can't works with null proto objects.\r\nvar $      = require('./$')\r\n  , assert = require('./$.assert');\r\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function(buggy, set){\r\n  try {\r\n    set = require('./$.ctx')(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);\r\n    set({}, []);\r\n  } catch(e){ buggy = true }\r\n  return function(O, proto){\r\n    assert.obj(O);\r\n    assert(proto === null || $.isObject(proto), proto, \": can't set as prototype!\");\r\n    if(buggy)O.__proto__ = proto;\r\n    else set(O, proto);\r\n    return O;\r\n  }\r\n}() : undefined);",
    "var $ = require('./$');\r\nmodule.exports = function(C){\r\n  if($.DESC && $.FW)$.setDesc(C, require('./$.wks')('species'), {\r\n    configurable: true,\r\n    get: $.that\r\n  });\r\n}",
    "'use strict';\r\n// true  -> String#codePointAt\r\n// false -> String#at\r\nvar $ = require('./$');\r\nmodule.exports = function(TO_STRING){\r\n  return function(pos){\r\n    var s = String($.assertDefined(this))\r\n      , i = $.toInteger(pos)\r\n      , l = s.length\r\n      , a, b;\r\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\r\n    a = s.charCodeAt(i);\r\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\r\n      ? TO_STRING ? s.charAt(i) : a\r\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\r\n  }\r\n}",
    "var sid = 0\r\nfunction uid(key){\r\n  return 'Symbol(' + key + ')_' + (++sid + Math.random()).toString(36);\r\n}\r\nuid.safe = require('./$').g.Symbol || uid;\r\nmodule.exports = uid;",
    "var global = require('./$').g\r\n  , store  = {};\r\nmodule.exports = function(name){\r\n  return store[name] || (store[name] =\r\n    (global.Symbol && global.Symbol[name]) || require('./$.uid').safe('Symbol.' + name));\r\n}",
    "require('./es6.iterators');\r\nvar $     = require('./$')\r\n  , ctx   = require('./$.ctx')\r\n  , $def  = require('./$.def')\r\n  , $iter = require('./$.iter')\r\n  , stepCall = $iter.stepCall\r\n  , assertDefined = $.assertDefined;\r\nfunction generic(A, B){\r\n  // strange IE quirks mode bug -> use typeof instead of isFunction\r\n  return typeof A == 'function' ? A : B;\r\n}\r\n$def($def.S + $def.F * $iter.DANGER_CLOSING, 'Array', {\r\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\r\n  from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\r\n    var O       = Object(assertDefined(arrayLike))\r\n      , mapfn   = arguments[1]\r\n      , mapping = mapfn !== undefined\r\n      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined\r\n      , index   = 0\r\n      , length, result, step, iterator;\r\n    if($iter.is(O)){\r\n      iterator = $iter.get(O);\r\n      result   = new (generic(this, Array));\r\n      for(; !(step = iterator.next()).done; index++){\r\n        result[index] = mapping ? stepCall(iterator, f, [step.value, index], true) : step.value;\r\n      }\r\n    } else {\r\n      result = new (generic(this, Array))(length = $.toLength(O.length));\r\n      for(; length > index; index++){\r\n        result[index] = mapping ? f(O[index], index) : O[index];\r\n      }\r\n    }\r\n    result.length = index;\r\n    return result;\r\n  }\r\n});\r\n\r\n$def($def.S, 'Array', {\r\n  // 22.1.2.3 Array.of( ...items)\r\n  of: function(/* ...args */){\r\n    var index  = 0\r\n      , length = arguments.length\r\n      , result = new (generic(this, Array))(length);\r\n    while(length > index)result[index] = arguments[index++];\r\n    result.length = length;\r\n    return result;\r\n  }\r\n});\r\n\r\nrequire('./$.species')(Array);",
    "'use strict';\r\nrequire('./es6.iterators');\r\nvar $        = require('./$')\r\n  , ctx      = require('./$.ctx')\r\n  , cof      = require('./$.cof')\r\n  , $def     = require('./$.def')\r\n  , safe     = require('./$.uid').safe\r\n  , $iter    = require('./$.iter')\r\n  , assert   = require('./$.assert')\r\n  , assertInstanse = assert.inst\r\n  , has      = $.has\r\n  , set      = $.set\r\n  , isObject = $.isObject\r\n  , hide     = $.hide\r\n  , step     = $iter.step\r\n  , isFrozen = Object.isFrozen || $.core.Object.isFrozen\r\n  , CID      = safe('cid')\r\n  , O1       = safe('O1')\r\n  , WEAK     = safe('weak')\r\n  , LEAK     = safe('leak')\r\n  , LAST     = safe('last')\r\n  , FIRST    = safe('first')\r\n  , ITER     = safe('iter')\r\n  , SIZE     = $.DESC ? safe('size') : 'size'\r\n  , cid      = 0\r\n  , tmp      = {};\r\n\r\nfunction getCollection(NAME, methods, commonMethods, isMap, isWeak){\r\n  var Base  = $.g[NAME]\r\n    , C     = Base\r\n    , ADDER = isMap ? 'set' : 'add'\r\n    , proto = C && C.prototype\r\n    , O     = {};\r\n  function initFromIterable(that, iterable){\r\n    if(iterable != undefined)$iter.forOf(iterable, isMap, that[ADDER], that);\r\n    return that;\r\n  }\r\n  function fixSVZ(key, chain){\r\n    var method = proto[key];\r\n    if($.FW)proto[key] = function(a, b){\r\n      var result = method.call(this, a === 0 ? 0 : a, b);\r\n      return chain ? this : result;\r\n    };\r\n  }\r\n  function checkIter(){\r\n    var done = false;\r\n    var O = {next: function(){\r\n      done = true;\r\n      return step(1);\r\n    }};\r\n    O[SYMBOL_ITERATOR] = $.that;\r\n    try { new C(O) } catch(e){}\r\n    return done;\r\n  }\r\n  if(!$.isFunction(C) || !(isWeak || (!$iter.BUGGY && proto.forEach && proto.entries))){\r\n    // create collection constructor\r\n    C = isWeak\r\n      ? function(iterable){\r\n          set(assertInstanse(this, C, NAME), CID, cid++);\r\n          initFromIterable(this, iterable);\r\n        }\r\n      : function(iterable){\r\n          var that = assertInstanse(this, C, NAME);\r\n          set(that, O1, $.create(null));\r\n          set(that, SIZE, 0);\r\n          set(that, LAST, undefined);\r\n          set(that, FIRST, undefined);\r\n          initFromIterable(that, iterable);\r\n        };\r\n    $.mix($.mix(C.prototype, methods), commonMethods);\r\n    isWeak || !$.DESC || $.setDesc(C.prototype, 'size', {get: function(){\r\n      return assert.def(this[SIZE]);\r\n    }});\r\n  } else {\r\n    var Native = C\r\n      , inst   = new C\r\n      , chain  = inst[ADDER](isWeak ? {} : -0, 1)\r\n      , buggyZero;\r\n    // wrap to init collections from iterable\r\n    if($iter.DANGER_CLOSING || !checkIter()){\r\n      C = function(iterable){\r\n        assertInstanse(this, C, NAME);\r\n        return initFromIterable(new Native, iterable);\r\n      }\r\n      C.prototype = proto;\r\n      if($.FW)proto.constructor = C;\r\n    }\r\n    isWeak || inst.forEach(function(val, key){\r\n      buggyZero = 1 / key === -Infinity;\r\n    });\r\n    // fix converting -0 key to +0\r\n    if(buggyZero){\r\n      fixSVZ('delete');\r\n      fixSVZ('has');\r\n      isMap && fixSVZ('get');\r\n    }\r\n    // + fix .add & .set for chaining\r\n    if(buggyZero || chain !== inst)fixSVZ(ADDER, true);\r\n  }\r\n  cof.set(C, NAME);\r\n  require('./$.species')(C);\r\n  \r\n  O[NAME] = C;\r\n  $def($def.G + $def.W + $def.F * (C != Base), O);\r\n  \r\n  // add .keys, .values, .entries, [@@iterator]\r\n  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\r\n  isWeak || $iter.std(C, NAME, function(iterated, kind){\r\n    set(this, ITER, {o: iterated, k: kind});\r\n  }, function(){\r\n    var iter  = this[ITER]\r\n      , kind  = iter.k\r\n      , entry = iter.l;\r\n    // revert to the last existing entry\r\n    while(entry && entry.r)entry = entry.p;\r\n    // get next entry\r\n    if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){\r\n      // or finish the iteration\r\n      iter.o = undefined;\r\n      return step(1);\r\n    }\r\n    // return step by kind\r\n    if(kind == 'key')   return step(0, entry.k);\r\n    if(kind == 'value') return step(0, entry.v);\r\n                        return step(0, [entry.k, entry.v]);   \r\n  }, isMap ? 'key+value' : 'value', !isMap, true);\r\n  \r\n  return C;\r\n}\r\n\r\nfunction fastKey(it, create){\r\n  // return primitive with prefix\r\n  if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;\r\n  // can't set id to frozen object\r\n  if(isFrozen(it))return 'F';\r\n  if(!has(it, CID)){\r\n    // not necessary to add id\r\n    if(!create)return 'E';\r\n    // add missing object id\r\n    hide(it, CID, ++cid);\r\n  // return object id with prefix\r\n  } return 'O' + it[CID];\r\n}\r\nfunction getEntry(that, key){\r\n  // fast case\r\n  var index = fastKey(key), entry;\r\n  if(index != 'F')return that[O1][index];\r\n  // frozen object case\r\n  for(entry = that[FIRST]; entry; entry = entry.n){\r\n    if(entry.k == key)return entry;\r\n  }\r\n}\r\nfunction def(that, key, value){\r\n  var entry = getEntry(that, key)\r\n    , prev, index;\r\n  // change existing entry\r\n  if(entry)entry.v = value;\r\n  // create new entry\r\n  else {\r\n    that[LAST] = entry = {\r\n      i: index = fastKey(key, true), // <- index\r\n      k: key,                        // <- key\r\n      v: value,                      // <- value\r\n      p: prev = that[LAST],          // <- previous entry\r\n      n: undefined,                  // <- next entry\r\n      r: false                       // <- removed\r\n    };\r\n    if(!that[FIRST])that[FIRST] = entry;\r\n    if(prev)prev.n = entry;\r\n    that[SIZE]++;\r\n    // add to index\r\n    if(index != 'F')that[O1][index] = entry;\r\n  } return that;\r\n}\r\n\r\nvar collectionMethods = {\r\n  // 23.1.3.1 Map.prototype.clear()\r\n  // 23.2.3.2 Set.prototype.clear()\r\n  clear: function(){\r\n    for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){\r\n      entry.r = true;\r\n      if(entry.p)entry.p = entry.p.n = undefined;\r\n      delete data[entry.i];\r\n    }\r\n    that[FIRST] = that[LAST] = undefined;\r\n    that[SIZE] = 0;\r\n  },\r\n  // 23.1.3.3 Map.prototype.delete(key)\r\n  // 23.2.3.4 Set.prototype.delete(value)\r\n  'delete': function(key){\r\n    var that  = this\r\n      , entry = getEntry(that, key);\r\n    if(entry){\r\n      var next = entry.n\r\n        , prev = entry.p;\r\n      delete that[O1][entry.i];\r\n      entry.r = true;\r\n      if(prev)prev.n = next;\r\n      if(next)next.p = prev;\r\n      if(that[FIRST] == entry)that[FIRST] = next;\r\n      if(that[LAST] == entry)that[LAST] = prev;\r\n      that[SIZE]--;\r\n    } return !!entry;\r\n  },\r\n  // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\r\n  // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\r\n  forEach: function(callbackfn /*, that = undefined */){\r\n    var f = ctx(callbackfn, arguments[1], 3)\r\n      , entry;\r\n    while(entry = entry ? entry.n : this[FIRST]){\r\n      f(entry.v, entry.k, this);\r\n      // revert to the last existing entry\r\n      while(entry && entry.r)entry = entry.p;\r\n    }\r\n  },\r\n  // 23.1.3.7 Map.prototype.has(key)\r\n  // 23.2.3.7 Set.prototype.has(value)\r\n  has: function(key){\r\n    return !!getEntry(this, key);\r\n  }\r\n}\r\n\r\n// 23.1 Map Objects\r\nvar Map = getCollection('Map', {\r\n  // 23.1.3.6 Map.prototype.get(key)\r\n  get: function(key){\r\n    var entry = getEntry(this, key);\r\n    return entry && entry.v;\r\n  },\r\n  // 23.1.3.9 Map.prototype.set(key, value)\r\n  set: function(key, value){\r\n    return def(this, key === 0 ? 0 : key, value);\r\n  }\r\n}, collectionMethods, true);\r\n\r\n// 23.2 Set Objects\r\ngetCollection('Set', {\r\n  // 23.2.3.1 Set.prototype.add(value)\r\n  add: function(value){\r\n    return def(this, value = value === 0 ? 0 : value, value);\r\n  }\r\n}, collectionMethods);\r\n\r\nfunction defWeak(that, key, value){\r\n  if(isFrozen(assert.obj(key)))leakStore(that).set(key, value);\r\n  else {\r\n    has(key, WEAK) || hide(key, WEAK, {});\r\n    key[WEAK][that[CID]] = value;\r\n  } return that;\r\n}\r\nfunction leakStore(that){\r\n  return that[LEAK] || hide(that, LEAK, new Map)[LEAK];\r\n}\r\n\r\nvar weakMethods = {\r\n  // 23.3.3.2 WeakMap.prototype.delete(key)\r\n  // 23.4.3.3 WeakSet.prototype.delete(value)\r\n  'delete': function(key){\r\n    if(!isObject(key))return false;\r\n    if(isFrozen(key))return leakStore(this)['delete'](key);\r\n    return has(key, WEAK) && has(key[WEAK], this[CID]) && delete key[WEAK][this[CID]];\r\n  },\r\n  // 23.3.3.4 WeakMap.prototype.has(key)\r\n  // 23.4.3.4 WeakSet.prototype.has(value)\r\n  has: function(key){\r\n    if(!isObject(key))return false;\r\n    if(isFrozen(key))return leakStore(this).has(key);\r\n    return has(key, WEAK) && has(key[WEAK], this[CID]);\r\n  }\r\n};\r\n\r\n// 23.3 WeakMap Objects\r\nvar WeakMap = getCollection('WeakMap', {\r\n  // 23.3.3.3 WeakMap.prototype.get(key)\r\n  get: function(key){\r\n    if(isObject(key)){\r\n      if(isFrozen(key))return leakStore(this).get(key);\r\n      if(has(key, WEAK))return key[WEAK][this[CID]];\r\n    }\r\n  },\r\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\r\n  set: function(key, value){\r\n    return defWeak(this, key, value);\r\n  }\r\n}, weakMethods, true, true);\r\n\r\n// IE11 WeakMap frozen keys fix\r\nif($.FW && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){\r\n  $.each.call($.a('delete,has,get,set'), function(key){\r\n    var method = WeakMap.prototype[key];\r\n    WeakMap.prototype[key] = function(a, b){\r\n      // store frozen objects on leaky map\r\n      if(isObject(a) && isFrozen(a)){\r\n        var result = leakStore(this)[key](a, b);\r\n        return key == 'set' ? this : result;\r\n      // store all the rest on native weakmap\r\n      } return method.call(this, a, b);\r\n    };\r\n  });\r\n}\r\n\r\n// 23.4 WeakSet Objects\r\ngetCollection('WeakSet', {\r\n  // 23.4.3.1 WeakSet.prototype.add(value)\r\n  add: function(value){\r\n    return defWeak(this, value, true);\r\n  }\r\n}, weakMethods, false, true);",
    "var $     = require('./$')\r\n  , at    = require('./$.string-at')(true)\r\n  , ITER  = require('./$.uid').safe('iter')\r\n  , $iter = require('./$.iter')\r\n  , step  = $iter.step\r\n  , Iterators = $iter.Iterators;\r\n// 22.1.3.4 Array.prototype.entries()\r\n// 22.1.3.13 Array.prototype.keys()\r\n// 22.1.3.29 Array.prototype.values()\r\n// 22.1.3.30 Array.prototype[@@iterator]()\r\n$iter.std(Array, 'Array', function(iterated, kind){\r\n  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});\r\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\r\n}, function(){\r\n  var iter  = this[ITER]\r\n    , O     = iter.o\r\n    , kind  = iter.k\r\n    , index = iter.i++;\r\n  if(!O || index >= O.length){\r\n    iter.o = undefined;\r\n    return step(1);\r\n  }\r\n  if(kind == 'key')   return step(0, index);\r\n  if(kind == 'value') return step(0, O[index]);\r\n                      return step(0, [index, O[index]]);\r\n}, 'value');\r\n\r\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\r\nIterators.Arguments = Iterators.Array;\r\n\r\n// 21.1.3.27 String.prototype[@@iterator]()\r\n$iter.std(String, 'String', function(iterated){\r\n  $.set(this, ITER, {o: String(iterated), i: 0});\r\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\r\n}, function(){\r\n  var iter  = this[ITER]\r\n    , O     = iter.o\r\n    , index = iter.i\r\n    , point;\r\n  if(index >= O.length)return step(1);\r\n  point = at.call(O, index);\r\n  iter.i += point.length;\r\n  return step(0, point);\r\n});",
    "var $def     = require('./$.def')\r\n  , setProto = require('./$.set-proto');\r\nvar objectStatic = {\r\n  // 19.1.3.1 Object.assign(target, source)\r\n  assign: require('./$.assign'),\r\n  // 19.1.3.10 Object.is(value1, value2)\r\n  is: function(x, y){\r\n    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\r\n  }\r\n};\r\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\r\nif(setProto)objectStatic.setPrototypeOf = setProto;\r\n$def($def.S, 'Object', objectStatic);",
    "'use strict';\r\n// ECMAScript 6 symbols shim\r\nvar $        = require('./$')\r\n  , setTag   = require('./$.cof').set\r\n  , uid      = require('./$.uid')\r\n  , $def     = require('./$.def')\r\n  , assert   = require('./$.assert')\r\n  , has      = $.has\r\n  , hide     = $.hide\r\n  , getNames = $.getNames\r\n  , toObject = $.toObject\r\n  , Symbol   = $.g.Symbol\r\n  , Base     = Symbol\r\n  , setter   = true\r\n  , TAG      = uid.safe('tag')\r\n  , SymbolRegistry = {}\r\n  , AllSymbols     = {};\r\n// 19.4.1.1 Symbol([description])\r\nif(!$.isFunction(Symbol)){\r\n  Symbol = function(description){\r\n    assert(!(this instanceof Symbol), 'Symbol is not a constructor');\r\n    var tag = uid(description)\r\n      , sym = $.set($.create(Symbol.prototype), TAG, tag);\r\n    AllSymbols[tag] = sym;\r\n    $.DESC && setter && $.setDesc(Object.prototype, tag, {\r\n      configurable: true,\r\n      set: function(value){\r\n        hide(this, tag, value);\r\n      }\r\n    });\r\n    return sym;\r\n  }\r\n  hide(Symbol.prototype, 'toString', function(){\r\n    return this[TAG];\r\n  });\r\n}\r\n$def($def.G + $def.W, {Symbol: Symbol});\r\n\r\nvar symbolStatics = {\r\n  // 19.4.2.1 Symbol.for(key)\r\n  'for': function(key){\r\n    return has(SymbolRegistry, key += '')\r\n      ? SymbolRegistry[key]\r\n      : SymbolRegistry[key] = Symbol(key);\r\n  },\r\n  // 19.4.2.5 Symbol.keyFor(sym)\r\n  keyFor: require('./$.partial').call(require('./$.keyof'), SymbolRegistry, 0),\r\n  pure: uid.safe,\r\n  set: $.set,\r\n  useSetter: function(){ setter = true },\r\n  useSimple: function(){ setter = false }\r\n};\r\n// 19.4.2.2 Symbol.hasInstance\r\n// 19.4.2.3 Symbol.isConcatSpreadable\r\n// 19.4.2.4 Symbol.iterator\r\n// 19.4.2.6 Symbol.match\r\n// 19.4.2.8 Symbol.replace\r\n// 19.4.2.9 Symbol.search\r\n// 19.4.2.10 Symbol.species\r\n// 19.4.2.11 Symbol.split\r\n// 19.4.2.12 Symbol.toPrimitive\r\n// 19.4.2.13 Symbol.toStringTag\r\n// 19.4.2.14 Symbol.unscopables\r\n$.each.call($.a('hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'),\r\n  function(it){\r\n    symbolStatics[it] = require('./$.wks')(it);\r\n  }\r\n);\r\n\r\n$def($def.S, 'Symbol', symbolStatics);\r\n\r\n$def($def.S + $def.F * (Symbol != Base), 'Object', {\r\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\r\n  getOwnPropertyNames: function(it){\r\n    var names = getNames(toObject(it)), result = [], key, i = 0;\r\n    while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);\r\n    return result;\r\n  },\r\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\r\n  getOwnPropertySymbols: function(it){\r\n    var names = getNames(toObject(it)), result = [], key, i = 0;\r\n    while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);\r\n    return result;\r\n  }\r\n});\r\n\r\nsetTag(Symbol, 'Symbol');\r\n// 20.2.1.9 Math[@@toStringTag]\r\nsetTag(Math, 'Math', true);\r\n// 24.3.3 JSON[@@toStringTag]\r\nsetTag($.g.JSON, 'JSON', true);",
    "/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var iteratorSymbol =\n    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    genFun.__proto__ = GeneratorFunctionPrototype;\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    return new Promise(function(resolve, reject) {\n      var generator = wrap(innerFn, outerFn, self, tryLocsList);\n      var callNext = step.bind(generator.next);\n      var callThrow = step.bind(generator[\"throw\"]);\n\n      function step(arg) {\n        var record = tryCatch(this, null, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n          return;\n        }\n\n        var info = record.arg;\n        if (info.done) {\n          resolve(info.value);\n        } else {\n          Promise.resolve(info.value).then(callNext, callThrow);\n        }\n      }\n\n      callNext();\n    });\n  };\n\n  function Generator(innerFn, outerFn, self, tryLocsList) {\n    var generator = outerFn ? Object.create(outerFn.prototype) : this;\n    var context = new Context(tryLocsList);\n    var state = GenStateSuspendedStart;\n\n    function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          if (state === GenStateSuspendedStart &&\n              typeof arg !== \"undefined\") {\n            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n            throw new TypeError(\n              \"attempt to send \" + JSON.stringify(arg) + \" to newborn generator\"\n            );\n          }\n\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            delete context.sent;\n          }\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n\n          if (method === \"next\") {\n            context.dispatchException(record.arg);\n          } else {\n            arg = record.arg;\n          }\n        }\n      }\n    }\n\n    generator.next = invoke.bind(generator, \"next\");\n    generator[\"throw\"] = invoke.bind(generator, \"throw\");\n    generator[\"return\"] = invoke.bind(generator, \"return\");\n\n    return generator;\n  }\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset();\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function() {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      // Pre-initialize at least 20 temporary variables to enable hidden\n      // class optimizations for simple generators.\n      for (var tempIndex = 0, tempName;\n           hasOwn.call(this, tempName = \"t\" + tempIndex) || tempIndex < 20;\n           ++tempIndex) {\n        this[tempName] = null;\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg < finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          return this.complete(entry.completion, entry.afterLoc);\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window : this\n);\n"
  ]
}